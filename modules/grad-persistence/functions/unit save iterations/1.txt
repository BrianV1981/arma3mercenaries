/*

grad-persistense group saves
Enhanced By: BrianV1981

---

## Summary of Changes and Logic

### Objective
The goal was to create a persistent system for saving and loading specific AI units marked with unique variables/tags that are also tied to the player 
and their respectove groups. The system assigns unique identifiers to units and groups based on the player's UID and ensure these identifiers are consistently saved and reloaded.

### Key Concepts

1. **AI Unit ID (`arma3mercenaries_aiUnit`)**:
   - **Purpose**: Uniquely identifies each AI unit associated with a player.
   - **Format**: `arma3mercenaries_aiUnit_*uniqueUnitID*_*playerUID*`.
   - **Logic**: Generated during the unit creation process to ensure each AI unit has a distinct ID tied to the player who created it.

2. **Group ID (`arma3mercenaries_groupID`)**:
   - **Purpose**: Uniquely identifies a group of AI units associated with a player.
   - **Format**: `arma3mercenaries_groupID_*playerUID*`.
   - **Logic**: The group ID is created once for each player's group and applied to all units within that group. This ensures that upon loading, all units can be correctly reassigned to their respective player’s group.

### Implementation Details

#### 1. **Unit Creation Script**
   - **Logic**:
     - When an AI unit is created, it is assigned an `arma3mercenaries_aiUnit` variable, which includes a unique identifier and the player’s UID.
     - It also receives an `arma3mercenaries_groupID` variable based solely on the player’s UID.
   - **Purpose**: Ensures that each unit is correctly tagged with identifiers that can be used for saving and reloading.

#### 2. **Saving Script**
   - **Logic**:
     - During the save process, each group of AI units is checked to ensure it has a valid group leader (the player) with a corresponding `arma3mercenaries_groupID`.
     - The units within each group are then processed, and their relevant data, including their AI Unit ID and Group ID, is saved.
   - **Purpose**: Ensures that all relevant data for units and groups is stored for later retrieval, preserving the structure and relationships.

#### 3. **Loading Script**
   - **Logic**:
     - During the loading process, saved groups and units are restored based on their saved data.
     - Each unit is reassigned its `arma3mercenaries_aiUnit` and `arma3mercenaries_groupID` variables, ensuring they are placed back into their correct group.
   - **Purpose**: Ensures that when the mission is reloaded, all units and groups are restored to their original state, maintaining consistency across sessions.

### Rationale Behind the Logic

- **Consistency**: By tying both the AI Unit ID and Group ID to the player's UID, we ensure that the relationship between the player, their AI units, and their groups remains consistent across save/load cycles.
- **Simplicity**: The format and assignment of IDs are straightforward, making it easier to debug and manage within the mission.
- **Persistence**: The use of Grad Persistence functions ensures that all relevant data is saved and reloaded correctly, minimizing the risk of data loss or corruption.

---

*/
/////////////////////////////////////grad persistence config setup example

// https://github.com/gruppe-adler/grad-persistence/wiki/Configuration
// https://github.com/gruppe-adler/grad-persistence/wiki/Saving-Variables
class CfgGradPersistence {
    missionTag = "my_persistent_mission";
    loadOnMissionStart = 1;
    missionWaitCondition = "true";
    playerWaitCondition = "true";

    saveUnits = 3;
    saveVehicles = 3;
    saveContainers = 3;
    saveStatics = 0;
	saveGradFortificationsStatics = 3;
	
    savePlayerInventory = 1;
    savePlayerDamage = 1;
    savePlayerPosition = 1;
    savePlayerMoney = 1;
	
    saveMarkers = 3;
    saveTasks = 0;
    saveTriggers = 0;
    saveTeamAccounts = 0;
	saveTimeAndDate = 0;
	
	class customVariables {
        class acexFood {
            varName = "acex_field_rations_hunger";
            varNamespace = "player";
            public = 1;
        };
        class acexWater {
            varName = "acex_field_rations_thirst";
            varNamespace = "player";
            public = 1;
        };
		class gradFortificationsVehicleInventory {
          varName = "grad_fortifications_myFortsHash";
          varNamespace = "vehicle";
          public = 1;
      };
      class gradFortificationsContainerInventory {
          varName = "grad_fortifications_myFortsHash";
          varNamespace = "container";
          public = 1;
      };
      class gradFortificationsPlayerInventory {
          varName = "grad_fortifications_myFortsHash";
          varNamespace = "player";
          public = 1;
      };
      class gradFortificationsUnitInventory {
          varName = "grad_fortifications_myFortsHash";
          varNamespace = "unit";
          public = 1;
      };
	  
	  class hgOwner {
          varName = "HG_Owner"; // custom variable
          varNamespace = "vehicle"; // Since this variable is related to vehicles
          public = 1; // Make it public if needed, 0 if not
		};
	  
		class aiUnit {
            varName = "arma3mercenaries_aiUnit";
            varNamespace = "unit";
            public = 1;  // Set to 1 if you need it broadcast across the network
        };
        class groupID {
            varName = "arma3mercenaries_groupID";
            varNamespace = "unit";
            public = 1;
        };
    };
};



//////////////////////////////////////initplayerlocal setup example

// initPlayerLocal.sqf

// Get the player's UID
private _playerUID = getPlayerUID player;

// Create the group ID using the player's UID
private _groupID = format ["arma3mercenaries_groupID_%1", _playerUID];

// Assign the group ID to the player
player setVariable ["arma3mercenaries_groupID", _groupID, true];



/////////////////////////////////////code to have ai units rejoin player upon loading back iun after server restart

{
    private _unit = _x;
    if (!isPlayer _unit) then {
        [_unit] joinSilent group player;
    };
} forEach (allUnits select {
    _x getVariable ["arma3mercenaries_groupID", ""] == player getVariable ["arma3mercenaries_groupID", ""]
});


/////////////////////////////////////or...combine them into the initplayerlocal...

// initPlayerLocal.sqf

// Get the player's UID
private _playerUID = getPlayerUID player;

// Create the group ID using the player's UID
private _groupID = format ["arma3mercenaries_groupID_%1", _playerUID];

// Assign the group ID to the player
player setVariable ["arma3mercenaries_groupID", _groupID, true];

// Wait until the player is fully loaded
waitUntil {time > 0 && !isNull player};

// Reassign AI units with the matching group ID to the player's group
{
    private _unit = _x;
    if (!isPlayer _unit) then {
        [_unit] joinSilent group player;
    };
} forEach (allUnits select {
    _x getVariable ["arma3mercenaries_groupID", ""] == player getVariable ["arma3mercenaries_groupID", ""]
});

/////////////////////////////////////


```

#include "script_component.hpp"

if (!isServer) exitWith {};

private _missionTag = [] call grad_persistence_fnc_getMissionTag;
private _groupsTag = _missionTag + "_groups";
private _groupsData = [_groupsTag] call grad_persistence_fnc_getSaveData;

{
    _x params ["_thisGroupSide","_thisGroupUnits","_thisGroupVars"];
    private _thisGroup = createGroup _thisGroupSide;

    {
        _thisUnitHash = _x;

        private _vehVarName = [_thisUnitHash,"varName"] call CBA_fnc_hashGet;

        private _thisUnit = objNull;
        private _editorVehicleFound = false;
        if (!isNil "_vehVarName") then {
            // editor-placed object that already exists
            private _editorVehicle = call compile _vehVarName;
            if (!isNil "_editorVehicle") then {
                _thisUnit = _editorVehicle;
                _editorVehicleFound = true;
            };
        };

        if (!_editorVehicleFound) then {
            private _type = [_thisUnitHash,"type"] call CBA_fnc_hashGet;
            _thisUnit = _thisGroup createUnit [_type, [0,0,0], [], 0, "CAN_COLLIDE"];

            if (!isNil "_vehVarName") then {
                [_thisVehicle,_vehVarName] remoteExec ["setVehicleVarName",0,_thisVehicle];
            };
        };

        [{!isNull (_this select 0)}, {
            params ["_thisUnit","_thisUnitHash"];

            private _posASL = [_thisUnitHash,"posASL"] call CBA_fnc_hashGet;
            private _dir = [_thisUnitHash,"dir"] call CBA_fnc_hashGet;
            private _damage = [_thisUnitHash,"damage"] call CBA_fnc_hashGet;
            private _vars = [_thisUnitHash,"vars"] call CBA_fnc_hashGet;

            _thisUnit setDir _dir;
            _thisUnit setPosASL _posASL;
            _thisUnit setDamage _damage;

            // Reapply the AI Unit ID and Group ID variables
            private _aiUnitID = [_thisUnitHash,"arma3mercenaries_aiUnit"] call CBA_fnc_hashGet;
            private _groupID = [_thisUnitHash,"arma3mercenaries_groupID"] call CBA_fnc_hashGet;
            _thisUnit setVariable ["arma3mercenaries_aiUnit", _aiUnitID, true];
            _thisUnit setVariable ["arma3mercenaries_groupID", _groupID, true];

            [_vars,_thisUnit] call FUNC(loadObjectVars);
        },[_thisUnit,_thisUnitHash]] call CBA_fnc_waitUntilAndExecute;

    } forEach _thisGroupUnits;

    [_thisGroupVars,_thisGroup] call FUNC(loadObjectVars);

} forEach _groupsData;

// delete all editor vehicles that were killed in a previous save
private _killedVarnames = [_missionTag + "_killedVarnames"] call FUNC(getSaveData);
private _killedUnitsVarnames = _killedVarnames param [0,[]];
{
    private _editorVehicle = call compile _x;
    if (!isNil "_editorVehicle") then {deleteVehicle _editorVehicle};
} forEach _killedUnitsVarnames;
```

```
/*  Saves groups in format:
*   [[side of group, unitsData],[side of group, unitsData],[...]]
*
*   unitsData:
*   [unit hash, unit hash, unit hash, [...]]
*/

#include "script_component.hpp"

if (!isServer) exitWith {};

params [["_area",false],["_allVariableClasses",[]]];

private _allGroupsVariableClasses = _allVariableClasses select {
    ([_x,"varNamespace",""] call BIS_fnc_returnConfigEntry) == "group"
};

private _allUnitsVariableClasses = _allVariableClasses select {
    ([_x,"varNamespace",""] call BIS_fnc_returnConfigEntry) == "unit"
};

if (_area isEqualType []) then {
    _area params ["_center","_a","_b",["_angle",0],["_isRectangle",false],["_c",-1]];
    if (isNil "_b") then {_b = _a};
    _area = [_center,_a,_b,_angle,_isRectangle,_c];
};

private _missionTag = [] call FUNC(getMissionTag);
private _groupsTag = _missionTag + "_groups";
private _groupsData = [_groupsTag] call FUNC(getSaveData);
private _foundUnitsVarnames = GVAR(allFoundVarNames) select 0;
_groupsData resize 0;

private _allGroups = allGroups;
private _saveGroupsMode = [missionConfigFile >> "CfgGradPersistence", "saveUnits", 1] call BIS_fnc_returnConfigEntry;

{
    private _thisGroup = _x;
    private _thisGroupData = [side _x,[],[]];
    private _thisUnitsData = _thisGroupData select 1;

    // Generate a Group ID using the player's UID (if the group leader is a player)
    private _groupOwner = leader _thisGroup;
    private _groupOwnerUID = _groupOwner getVariable ["arma3mercenaries_groupID", ""];

    if (!isNil "_groupOwnerUID" && {_groupOwnerUID != ""}) then {
        _thisGroupData pushBack _groupOwnerUID; // Store the group ID in the group's data

        {
            private _thisUnit = _x;

            if (
                    !(isPlayer _thisUnit) &&
                    {!(isNull _thisUnit)} &&
                    {alive _thisUnit} &&
                    // {vehicle _thisUnit == _thisUnit} && // removed check for units in vehicles (the check removes units from being saved)
                    {!([_thisUnit] call FUNC(isBlacklisted))} &&
                    {!((group _thisUnit) getVariable [QGVAR(isExcluded),false])} &&
                    {
                        _saveGroupsMode == 2 ||
                        (_thisUnit getVariable [QGVAR(isEditorObject),false]) isEqualTo (_saveGroupsMode == 1)
                    } &&
                    {if (_area isEqualType false) then {true} else {_thisUnit inArea _area}}
                ) then {

                _thisUnitHash = [] call CBA_fnc_hashCreate;

                private _vehVarName = vehicleVarName _thisUnit;
                if (_vehVarName != "") then {
                    [_thisUnitHash,"varName",_vehVarName] call CBA_fnc_hashSet;
                    _foundUnitsVarnames deleteAt (_foundUnitsVarnames find _vehVarName);
                };

                [_thisUnitHash,"type",typeOf _thisUnit] call CBA_fnc_hashSet;
                [_thisUnitHash,"posASL",getPosASL _thisUnit] call CBA_fnc_hashSet;
                [_thisUnitHash,"dir",getDir _thisUnit] call CBA_fnc_hashSet;
                [_thisUnitHash,"damage",damage _thisUnit] call CBA_fnc_hashSet;

                // Save the AI Unit ID and Group ID
                private _aiUnitID = _thisUnit getVariable ["arma3mercenaries_aiUnit", ""];
                if (_aiUnitID != "") then {
                    [_thisUnitHash,"arma3mercenaries_aiUnit",_aiUnitID] call CBA_fnc_hashSet;
                };
                [_thisUnitHash,"arma3mercenaries_groupID",_groupOwnerUID] call CBA_fnc_hashSet;

                private _thisUnitVars = [_allUnitsVariableClasses,_thisUnit] call FUNC(saveObjectVars);
                [_thisUnitHash,"vars",_thisUnitVars] call CBA_fnc_hashSet;

                _thisUnitsData pushBack _thisUnitHash;
            };

        } forEach (units _thisGroup);

        // only save if group has units that were saved
        if (count (_thisGroupData select 1) > 0) then {
            _groupsData pushBack _thisGroupData;
            _thisGroupData set [2,[_allGroupsVariableClasses,_thisGroup] call FUNC(saveObjectVars)];
        };
    };

    false
} count _allGroups;

// all _foundVehiclesVarnames that were not saved must have been removed or killed --> add to killedVarNames array
private _killedVarnames = [_missionTag + "_killedVarnames"] call FUNC(getSaveData);
private _killedUnitsVarnames = _killedVarnames param [0,[]];
_killedUnitsVarnames append _foundUnitsVarnames;
_killedUnitsVarnames arrayIntersect _killedUnitsVarnames;
_killedVarnames set [0,_killedUnitsVarnames];

saveProfileNamespace;
```
